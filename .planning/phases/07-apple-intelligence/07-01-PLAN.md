---
phase: 07-apple-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CoffeeJournal/Services/Insights/InsightsService.swift
  - CoffeeJournal/Services/Insights/FlavorExtractor.swift
  - CoffeeJournal/Services/Insights/NLInsightsService.swift
  - CoffeeJournal/Services/Insights/FoundationModelInsightsService.swift
  - CoffeeJournal/Services/Insights/BrewPatternAnalyzer.swift
  - CoffeeJournal/Services/Insights/BrewSuggestionEngine.swift
autonomous: true

must_haves:
  truths:
    - "FlavorExtractor produces flavor matches from freeform text against FlavorWheel vocabulary using NLTagger + NLEmbedding"
    - "BrewPatternAnalyzer identifies grind preferences by origin and optimal ratios by method from brew history"
    - "BrewSuggestionEngine suggests parameters from similar high-rated brews, falling back to same-origin when same-bean has no history"
    - "InsightsService protocol abstracts NL and Foundation Models implementations behind a single API"
    - "Foundation Models code compiles conditionally with #if canImport(FoundationModels) and @available(iOS 26, *)"
  artifacts:
    - path: "CoffeeJournal/Services/Insights/InsightsService.swift"
      provides: "InsightsService protocol, ExtractedFlavor, BrewPattern, BrewSuggestion types"
      contains: "protocol InsightsService"
    - path: "CoffeeJournal/Services/Insights/FlavorExtractor.swift"
      provides: "NLTagger + NLEmbedding flavor extraction pipeline"
      contains: "NLTagger"
    - path: "CoffeeJournal/Services/Insights/NLInsightsService.swift"
      provides: "NaturalLanguage-based InsightsService implementation (always available)"
      contains: "class NLInsightsService"
    - path: "CoffeeJournal/Services/Insights/FoundationModelInsightsService.swift"
      provides: "Foundation Models InsightsService implementation (iOS 26+)"
      contains: "canImport(FoundationModels)"
    - path: "CoffeeJournal/Services/Insights/BrewPatternAnalyzer.swift"
      provides: "Statistical pattern detection from brew history"
      contains: "struct BrewPatternAnalyzer"
    - path: "CoffeeJournal/Services/Insights/BrewSuggestionEngine.swift"
      provides: "Parameter suggestion from similar brews"
      contains: "struct BrewSuggestionEngine"
  key_links:
    - from: "CoffeeJournal/Services/Insights/FlavorExtractor.swift"
      to: "CoffeeJournal/Models/FlavorWheel.swift"
      via: "FlavorWheel.flatDescriptors() for vocabulary, FlavorWheel.findNode(byId:) for lookup"
      pattern: "FlavorWheel\\.flatDescriptors"
    - from: "CoffeeJournal/Services/Insights/NLInsightsService.swift"
      to: "CoffeeJournal/Services/Insights/InsightsService.swift"
      via: "conforms to InsightsService protocol"
      pattern: "InsightsService"
    - from: "CoffeeJournal/Services/Insights/BrewPatternAnalyzer.swift"
      to: "CoffeeJournal/Models/BrewLog.swift"
      via: "analyzes [BrewLog] with rating, brewRatio, grinderSetting, coffeeBean.origin, brewMethod.name"
      pattern: "BrewLog"
    - from: "CoffeeJournal/Services/Insights/BrewSuggestionEngine.swift"
      to: "CoffeeJournal/Models/BrewLog.swift"
      via: "queries BrewLog parameters for weighted average suggestions"
      pattern: "BrewLog"
---

<objective>
Build the AI insights service layer: flavor extraction from freeform text using NaturalLanguage framework, brewing pattern detection via statistical analysis of SwiftData history, and brew parameter suggestion engine.

Purpose: Establish the complete data/logic layer for AI-01 through AI-04. All ML processing is on-device. Foundation Models is an optional enhancement behind compile-time and runtime guards. NaturalLanguage-based implementation works on all iOS 17+ devices.

Output: Six service files in CoffeeJournal/Services/Insights/ providing the InsightsService protocol, NL-based and Foundation Models implementations, FlavorExtractor, BrewPatternAnalyzer, and BrewSuggestionEngine.
</objective>

<execution_context>
@/Users/ashok/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-apple-intelligence/07-RESEARCH.md
@CoffeeJournal/Models/FlavorWheel.swift
@CoffeeJournal/Models/BrewLog.swift
@CoffeeJournal/Models/CoffeeBean.swift
@CoffeeJournal/Models/TastingNote.swift
@CoffeeJournal/Models/BrewMethod.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InsightsService protocol, shared types, and FlavorExtractor</name>
  <files>
    CoffeeJournal/Services/Insights/InsightsService.swift
    CoffeeJournal/Services/Insights/FlavorExtractor.swift
  </files>
  <action>
Create `CoffeeJournal/Services/Insights/` directory.

**InsightsService.swift** — Define the protocol and all shared types:

1. `ExtractedFlavor` struct (Identifiable, Hashable):
   - `id: String` — FlavorWheel node ID or "extracted:word" for unmatched
   - `name: String` — display name
   - `confidence: Double` — 0.0 to 1.0
   - `source: ExtractionSource` enum with cases `.nlTagger`, `.nlEmbedding`, `.foundationModel`

2. `BrewPattern` struct (Identifiable):
   - `id: UUID`
   - `title: String` — e.g., "Grind for Ethiopia"
   - `description: String` — e.g., "Your best Ethiopian brews use grind setting ~15"
   - `category: PatternCategory` enum with cases `.grindPreference`, `.ratioOptimal`, `.methodFavorite`, `.originTrend`

3. `BrewSuggestion` struct:
   - `dose: Double`, `waterAmount: Double?`, `yieldAmount: Double?`, `waterTemperature: Double`, `grinderSetting: Double?`, `brewTime: Double`
   - `confidence: SuggestionConfidence` enum (`.high` = 5+ brews, `.medium` = 2-4, `.low` = 1)
   - `basedOnCount: Int`

4. `InsightsServiceFactory` struct:
   - `static func makeService() -> any InsightsService`
   - Uses `#if canImport(FoundationModels)` and `@available(iOS 26, *)` to check `SystemLanguageModel.default.availability`
   - Returns `FoundationModelInsightsService()` if available, else `NLInsightsService()`

5. `InsightsService` protocol:
   - `func extractFlavors(from text: String) async -> [ExtractedFlavor]`
   - `func analyzePatterns(brews: [BrewLog]) -> [BrewPattern]`
   - `func suggestParameters(for bean: CoffeeBean, method: BrewMethod, history: [BrewLog]) -> BrewSuggestion?`

**FlavorExtractor.swift** — NaturalLanguage-based flavor extraction pipeline:

1. `import NaturalLanguage`

2. `struct FlavorExtractor` with:
   - `private let flavorVocabulary: [String: String]` — lowercased name -> FlavorNode.id mapping
   - `init()` — populate from `FlavorWheel.flatDescriptors()`, mapping each leaf node's `name.lowercased()` to its `id`
   - Also add multi-word handling: for nodes with spaces (e.g., "Dark Chocolate"), store both "dark chocolate" and individual words ("chocolate") as fallback lookups

3. `func extract(from text: String) -> [ExtractedFlavor]`:
   - Step 1: Call `extractCandidateWords(from:)` to get adjectives and nouns via NLTagger `.lexicalClass` scheme
   - Step 2: Direct match -- for each candidate word (lowercased), check `flavorVocabulary`. If found, create `ExtractedFlavor` with confidence 1.0, source `.nlTagger`
   - Step 3: Also check bigrams -- combine consecutive candidates to match multi-word descriptors like "dark chocolate", "brown sugar"
   - Step 4: Fuzzy match via `NLEmbedding.wordEmbedding(for: .english)` -- for unmatched words, get `.neighbors(for: word.lowercased(), maximumCount: 3)`. If a neighbor exists in `flavorVocabulary` and distance < 0.8, create `ExtractedFlavor` with `confidence = max(0, 1.0 - distance)`, source `.nlEmbedding`. Skip words already matched.
   - Step 5: Deduplicate by `id`, keep highest confidence per id. Return sorted by confidence descending.

4. `private func extractCandidateWords(from text: String) -> [String]`:
   - Use `NLTagger(tagSchemes: [.lexicalClass])` with `.omitPunctuation, .omitWhitespace` options
   - Enumerate with `.word` unit, collect words tagged as `.adjective` or `.noun`
   - Return array preserving order (needed for bigram matching)

Key pitfall mitigations:
- Always `.lowercased()` before NLEmbedding lookup (Pitfall 1 from research)
- Distance < 0.8 threshold, not 1.0 (Pitfall 4 -- distances near 2.0 mean word not found)
- Deduplicate results to avoid repeated flavors from multiple source words
  </action>
  <verify>
Build the project with `swift build` from Package.swift (or verify no syntax errors via Xcode build). Confirm FlavorExtractor references FlavorWheel.flatDescriptors() and FlavorWheel.findNode(byId:). Confirm NLTagger and NLEmbedding imports compile.
  </verify>
  <done>
InsightsService protocol defined with extractFlavors/analyzePatterns/suggestParameters methods. ExtractedFlavor, BrewPattern, BrewSuggestion types defined. FlavorExtractor extracts candidate words via NLTagger, matches against FlavorWheel vocabulary directly and via NLEmbedding neighbors with distance-based confidence. InsightsServiceFactory selects NL or Foundation Models implementation at runtime.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NLInsightsService, FoundationModelInsightsService, BrewPatternAnalyzer, and BrewSuggestionEngine</name>
  <files>
    CoffeeJournal/Services/Insights/NLInsightsService.swift
    CoffeeJournal/Services/Insights/FoundationModelInsightsService.swift
    CoffeeJournal/Services/Insights/BrewPatternAnalyzer.swift
    CoffeeJournal/Services/Insights/BrewSuggestionEngine.swift
  </files>
  <action>
**NLInsightsService.swift** — NaturalLanguage-based implementation (always available):

1. `class NLInsightsService: InsightsService`
2. Private property: `let flavorExtractor = FlavorExtractor()`
3. Private property: `let patternAnalyzer = BrewPatternAnalyzer()`
4. Private property: `let suggestionEngine = BrewSuggestionEngine()`

5. `func extractFlavors(from text: String) async -> [ExtractedFlavor]`:
   - Delegate to `flavorExtractor.extract(from: text)`
   - Run on a background task context (NLTagger/NLEmbedding are fast but keep off main thread per research anti-patterns)

6. `func analyzePatterns(brews: [BrewLog]) -> [BrewPattern]`:
   - Delegate to `patternAnalyzer.analyzePatterns(brews: brews)`

7. `func suggestParameters(for bean: CoffeeBean, method: BrewMethod, history: [BrewLog]) -> BrewSuggestion?`:
   - Delegate to `suggestionEngine.suggest(for: bean, method: method, history: history)`

**FoundationModelInsightsService.swift** — Enhanced implementation (iOS 26+):

1. Wrap entire file in `#if canImport(FoundationModels)` / `#endif`
2. `import FoundationModels`
3. `@available(iOS 26, *)`
4. Define `@Generable struct TastingAnalysis`:
   - `@Guide(description: "Flavor descriptors found in the tasting notes") let descriptors: [String]`
   - `@Guide(description: "Overall sentiment: positive, neutral, or negative") let sentiment: String`
   - `@Guide(description: "One-sentence tasting profile summary") let summary: String`
5. `class FoundationModelInsightsService: InsightsService`:
   - Same `patternAnalyzer` and `suggestionEngine` properties as NLInsightsService (pattern analysis and suggestions are pure statistics, same in both tiers)
   - `extractFlavors`: Create `LanguageModelSession` with coffee tasting expert system prompt. Call `session.respond(to: "Analyze these coffee tasting notes: \(text)", generating: TastingAnalysis.self)`. Map returned descriptors to FlavorWheel node IDs using `FlavorWheel.findNode(byId:)` or vocabulary lookup. Wrap in do/catch -- on error, fall back to `FlavorExtractor().extract(from: text)` (NL baseline).
   - Keep prompts concise to stay within 4096 token limit (Pitfall 2)
   - `analyzePatterns`: Delegate to `patternAnalyzer` (same as NL)
   - `suggestParameters`: Delegate to `suggestionEngine` (same as NL)

**BrewPatternAnalyzer.swift** — Statistical pattern detection:

1. `struct BrewPatternAnalyzer`
2. `func analyzePatterns(brews: [BrewLog]) -> [BrewPattern]`:
   - Filter to rated brews (rating >= 4) for quality patterns
   - **Grind preferences by origin** (AI-02): Group by `coffeeBean?.origin`. For origins with 3+ brews, compute average `grinderSetting` weighted by rating. Create `.grindPreference` pattern: "Your best {origin} brews use grind setting ~{avg}".
   - **Optimal ratios by method** (AI-02): Group by `brewMethod?.name`. For methods with 3+ brews, compute average `brewRatio` (use the computed property on BrewLog). Create `.ratioOptimal` pattern: "Your top-rated {method} brews use 1:{avgRatio}".
   - **Favorite method** (bonus): Find method with most brews overall (all brews, not just rated). If count >= 5, create `.methodFavorite` pattern.
   - **Origin trend** (bonus): Find most-brewed origin. If 5+ brews, create `.originTrend` pattern.
   - Return patterns sorted: grindPreference first, then ratioOptimal, then others.
   - Guard against empty/zero values (skip origins where grinderSetting averages to 0, skip methods with no valid ratios).

**BrewSuggestionEngine.swift** — Parameter suggestions:

1. `struct BrewSuggestionEngine`
2. `func suggest(for bean: CoffeeBean, method: BrewMethod, history: [BrewLog]) -> BrewSuggestion?`:
   - Step 1: Find brews with **same bean AND same method** with rating >= 4: `history.filter { $0.coffeeBean?.id == bean.id && $0.brewMethod?.id == method.id && $0.rating >= 4 }`
   - Step 2: If none, fall back to **same origin AND same method** with rating >= 4: filter by `coffeeBean?.origin == bean.origin`
   - Step 3: If still none, return nil
   - Step 4: Compute weighted averages (weight = Double(rating)):
     - `dose`: weighted average of `$0.dose`
     - `waterAmount`: weighted average (only include brews where > 0), nil if none have it
     - `yieldAmount`: weighted average (only include brews where > 0), nil if none have it
     - `waterTemperature`: weighted average of `$0.waterTemperature`
     - `grinderSetting`: weighted average (only include brews where > 0), nil if none have it
     - `brewTime`: weighted average of `$0.brewTime`
   - Step 5: Determine confidence: count >= 5 = `.high`, >= 2 = `.medium`, 1 = `.low`
   - Step 6: Return `BrewSuggestion` with computed values and confidence
   - Minimum threshold: require at least 1 matching brew (Pitfall 5 from research -- display confidence clearly in UI, handled in Plan 02)
  </action>
  <verify>
Build the project. Confirm NLInsightsService conforms to InsightsService. Confirm FoundationModelInsightsService is behind `#if canImport(FoundationModels)` and compiles on current SDK (the code is excluded if SDK not present). Confirm BrewPatternAnalyzer uses BrewLog.brewRatio computed property. Confirm BrewSuggestionEngine filters by rating >= 4.
  </verify>
  <done>
NLInsightsService implements InsightsService using FlavorExtractor, BrewPatternAnalyzer, and BrewSuggestionEngine. FoundationModelInsightsService enhances flavor extraction with on-device LLM behind conditional compilation guards and falls back to NL on error. BrewPatternAnalyzer detects grind-by-origin and ratio-by-method patterns from 3+ rated brews. BrewSuggestionEngine computes weighted-average parameter suggestions from same-bean (falling back to same-origin) high-rated brews with confidence levels.
  </done>
</task>

</tasks>

<verification>
1. All 6 files exist under CoffeeJournal/Services/Insights/
2. InsightsService protocol has three methods: extractFlavors, analyzePatterns, suggestParameters
3. FlavorExtractor uses NLTagger for POS tagging and NLEmbedding for fuzzy matching against FlavorWheel vocabulary
4. BrewPatternAnalyzer produces patterns only from 3+ brews per category (no noisy 1-brew patterns)
5. BrewSuggestionEngine falls back from same-bean to same-origin matching
6. Foundation Models code compiles conditionally -- excluded when SDK not available
7. No network calls anywhere (AI-04 compliance)
8. Project builds without errors
</verification>

<success_criteria>
- InsightsService protocol and all types defined
- NLInsightsService works on all iOS 17+ devices
- FoundationModelInsightsService gated behind #if canImport and @available
- FlavorExtractor matches FlavorWheel vocabulary via direct match and NLEmbedding similarity
- BrewPatternAnalyzer identifies grind and ratio patterns from history
- BrewSuggestionEngine produces weighted-average suggestions with confidence levels
</success_criteria>

<output>
After completion, create `.planning/phases/07-apple-intelligence/07-01-SUMMARY.md`
</output>
