---
phase: 04-tasting-flavor-notes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CoffeeJournal/Models/FlavorWheel.swift
  - CoffeeJournal/Models/BrewLog.swift
  - CoffeeJournal/Models/TastingNote.swift
  - CoffeeJournal/Utilities/FlowLayout.swift
  - CoffeeJournal/ViewModels/TastingNoteViewModel.swift
  - CoffeeJournal/Views/Tasting/TastingNoteEntryView.swift
  - CoffeeJournal/Views/Tasting/AttributeSliderView.swift
  - CoffeeJournal/Views/Tasting/FlavorTagChipView.swift
  - CoffeeJournal/Views/Tasting/FlavorTagFlowView.swift
  - CoffeeJournal/Views/Brewing/BrewLogDetailView.swift
  - CoffeeJournal/Views/Brewing/AddBrewLogView.swift
  - Package.swift
autonomous: true

must_haves:
  truths:
    - "User can rate acidity, body, and sweetness on a 1-5 scale for any brew"
    - "User can select flavor tags from a hierarchical list and add custom flavor tags"
    - "Tasting notes are saved to SwiftData and sync via iCloud"
  artifacts:
    - path: "CoffeeJournal/Models/FlavorWheel.swift"
      provides: "Static SCA flavor wheel hierarchy with FlavorNode and 9 top-level categories"
      contains: "struct FlavorNode"
    - path: "CoffeeJournal/ViewModels/TastingNoteViewModel.swift"
      provides: "ViewModel managing tasting attribute state, flavor selections, JSON encoding/decoding, save logic"
      contains: "class TastingNoteViewModel"
    - path: "CoffeeJournal/Views/Tasting/TastingNoteEntryView.swift"
      provides: "Full tasting note entry form with sliders, flavor selection, custom tags, and save"
      contains: "struct TastingNoteEntryView"
    - path: "CoffeeJournal/Utilities/FlowLayout.swift"
      provides: "SwiftUI Layout protocol implementation for wrapping tag chips"
      contains: "struct FlowLayout"
    - path: "CoffeeJournal/Views/Tasting/AttributeSliderView.swift"
      provides: "Reusable 1-5 scale slider with label"
      contains: "struct AttributeSliderView"
    - path: "CoffeeJournal/Views/Tasting/FlavorTagChipView.swift"
      provides: "Individual flavor tag chip with selection toggle"
      contains: "struct FlavorTagChipView"
  key_links:
    - from: "CoffeeJournal/Views/Tasting/TastingNoteEntryView.swift"
      to: "CoffeeJournal/ViewModels/TastingNoteViewModel.swift"
      via: "@State private var viewModel"
      pattern: "TastingNoteViewModel"
    - from: "CoffeeJournal/ViewModels/TastingNoteViewModel.swift"
      to: "CoffeeJournal/Models/TastingNote.swift"
      via: "save method creates/updates TastingNote in modelContext"
      pattern: "modelContext.*TastingNote"
    - from: "CoffeeJournal/Views/Brewing/BrewLogDetailView.swift"
      to: "CoffeeJournal/Views/Tasting/TastingNoteEntryView.swift"
      via: "NavigationLink or sheet presentation"
      pattern: "TastingNoteEntryView"
    - from: "CoffeeJournal/Models/BrewLog.swift"
      to: "CoffeeJournal/Models/TastingNote.swift"
      via: "inverse relationship var tastingNote: TastingNote?"
      pattern: "tastingNote.*TastingNote"
---

<objective>
Build the tasting note data layer, entry form with attribute sliders and flavor tag selection, and wire into the brew detail flow.

Purpose: Establishes the foundation for all tasting functionality -- the FlavorWheel data structure, TastingNoteViewModel, and the primary entry form that users interact with to rate brews and select flavors. This plan creates the data and entry path; Plans 02 and 03 build the radial wheel UI and visualizations on top.

Output: Users can navigate from a brew detail to add/edit tasting notes with acidity/body/sweetness sliders (1-5), browse hierarchical flavor categories, select flavor tags, add custom tags, and save -- all persisted via SwiftData with iCloud sync.
</objective>

<execution_context>
@/Users/ashok/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tasting-flavor-notes/04-RESEARCH.md

# Prior phase context (BrewLog model and detail view this plan modifies)
@.planning/phases/03-brew-logging/03-03-SUMMARY.md

# Source files this plan modifies
@CoffeeJournal/Models/TastingNote.swift
@CoffeeJournal/Models/BrewLog.swift
@CoffeeJournal/Views/Brewing/BrewLogDetailView.swift
@CoffeeJournal/Views/Brewing/AddBrewLogView.swift
@CoffeeJournal/Views/Components/MonochromeStyle.swift
@Package.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FlavorWheel data, FlowLayout utility, TastingNoteViewModel, and update BrewLog inverse relationship</name>
  <files>
    CoffeeJournal/Models/FlavorWheel.swift
    CoffeeJournal/Models/BrewLog.swift
    CoffeeJournal/Models/TastingNote.swift
    CoffeeJournal/Utilities/FlowLayout.swift
    CoffeeJournal/ViewModels/TastingNoteViewModel.swift
    Package.swift
  </files>
  <action>
**1. Create FlavorWheel.swift** -- Static SCA flavor wheel hierarchy:

Define `FlavorNode` struct (Identifiable, Codable, Hashable) with fields: `id: String` (dot-path like "fruity.berry.strawberry"), `name: String`, `children: [FlavorNode]`. Add `var isLeaf: Bool { children.isEmpty }`.

Define `struct FlavorWheel` with `static let categories: [FlavorNode]` containing all 9 top-level SCA categories with their subcategories and specific descriptors:
- Floral (Floral: Jasmine/Rose/Chamomile, Tea-like: Black Tea/Green Tea)
- Fruity (Berry: Strawberry/Raspberry/Blueberry/Blackberry, Dried Fruit: Raisin/Prune/Coconut, Citrus: Grapefruit/Orange/Lemon/Lime, Other Fruit: Cherry/Pomegranate/Pineapple/Grape/Apple/Peach/Pear)
- Sour/Fermented (Sour: Acetic Acid/Butyric Acid/Citric Acid/Malic Acid, Fermented: Winey/Whiskey/Overripe)
- Green/Vegetative (Olive Oil, Raw: Under-ripe/Peapod/Fresh, Vegetative: Dark Green/Hay-like/Herb-like)
- Other (Papery/Musty: Stale/Cardboard/Papery/Woody/Musty-Dusty/Musty-Earthy/Animalic/Meaty-Brothy, Chemical: Phenolic/Bitter/Salty/Medicinal/Petroleum/Skunky/Rubber)
- Roasted (Pipe Tobacco, Cereal: Grain/Malt, Burnt: Smoky/Ashy/Acrid/Brown Roast)
- Spices (Pungent: Pepper, Brown Spice: Anise/Nutmeg/Cinnamon/Clove)
- Nutty/Cocoa (Nutty: Peanuts/Hazelnut/Almond, Cocoa: Dark Chocolate/Chocolate)
- Sweet (Brown Sugar: Molasses/Maple Syrup/Brown Sugar/Honey/Caramelized, Vanilla: Vanilla/Vanillin, Overall Sweet: Sweet Aromatics)

Add `static func flatDescriptors() -> [FlavorNode]` that recursively collects all leaf nodes for search.
Add `static func findNode(byId id: String) -> FlavorNode?` for looking up a node by its dot-path id.

**2. Update BrewLog.swift** -- Add inverse relationship for CloudKit sync:

Add `@Relationship(inverse: \TastingNote.brewLog) var tastingNote: TastingNote?` to the BrewLog model. This is safe since the app has not shipped and we are on SchemaV1. The existing `var brewLog: BrewLog?` on TastingNote already exists.

**3. Update TastingNote.swift** -- No model changes needed. The existing fields (acidity, body, sweetness as Int with default 0, flavorTags as String with default "", brewLog as BrewLog?) are exactly what we need. Verify the model is correct -- acidity/body/sweetness default to 0 (will represent "not rated" in the UI; 1-5 is the rated range).

**4. Create FlowLayout.swift** -- SwiftUI Layout protocol implementation:

Implement `struct FlowLayout: Layout` with `var spacing: CGFloat = 8`. Implement `sizeThatFits` and `placeSubviews` that arrange subviews left-to-right, wrapping to the next line when the current line exceeds available width. Follow the pattern from the research document exactly. This is a reusable utility for any wrapping layout.

**5. Create TastingNoteViewModel.swift** -- @Observable ViewModel:

Properties:
- `var acidity: Int = 0` (0 = not rated, 1-5 = rated)
- `var bodyRating: Int = 0` (named bodyRating to avoid conflict with SwiftUI View.body)
- `var sweetness: Int = 0`
- `var selectedFlavorIds: Set<String> = []` (FlavorNode dot-path IDs)
- `var customTags: [String] = []` (user-added tags)
- `var customTagInput: String = ""` (text field binding for adding custom tag)
- `var freeformNotes: String = ""`

Methods:
- `func toggleFlavor(_ id: String)` -- add/remove from selectedFlavorIds
- `func addCustomTag()` -- trim customTagInput, prefix with "custom:", add to customTags if non-empty and not duplicate, clear input
- `func removeCustomTag(_ tag: String)` -- remove from customTags
- `func loadFromTastingNote(_ note: TastingNote)` -- populate all fields from existing note, decode flavorTags JSON string into selectedFlavorIds and customTags (custom tags prefixed with "custom:")
- `func save(for brewLog: BrewLog, in context: ModelContext)` -- create or update TastingNote: set acidity/bodyRating/sweetness, encode selectedFlavorIds union customTags as JSON string into flavorTags, set freeformNotes, link to brewLog, set updatedAt. If brewLog.tastingNote exists, update it; otherwise insert new TastingNote.
- `var allDisplayTags: [(id: String, name: String)]` -- computed property returning selected flavors (looked up by name from FlavorWheel) plus custom tags (display name = tag without "custom:" prefix), sorted alphabetically
- `var hasChanges: Bool` -- true if any field is non-default

JSON encoding for flavorTags: Combine selectedFlavorIds (e.g. "fruity.berry.strawberry") and customTags (e.g. "custom:caramel") into a single `[String]` array, encode with JSONEncoder, store as String. On decode, split back: strings starting with "custom:" go to customTags, others go to selectedFlavorIds.

**6. Update Package.swift** -- Add new source files to the sources array:
- "Models/FlavorWheel.swift"
- "Utilities/FlowLayout.swift"
- "ViewModels/TastingNoteViewModel.swift"
(View files will be added in Task 2)
  </action>
  <verify>
Run `swift build` from the project root. The new files should compile without errors. Verify:
- FlavorWheel.categories has 9 top-level nodes
- FlavorWheel.flatDescriptors() returns 80+ leaf nodes
- BrewLog now has `var tastingNote: TastingNote?` with @Relationship inverse
- FlowLayout conforms to Layout protocol
- TastingNoteViewModel has all required properties and methods
  </verify>
  <done>
FlavorWheel data structure contains the full 3-tier SCA hierarchy. BrewLog has inverse relationship to TastingNote. TastingNoteViewModel manages tasting state with JSON encode/decode for flavor tags. FlowLayout provides wrapping layout. All compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tasting entry views (sliders, tag chips, flow layout, entry form) and wire into brew detail</name>
  <files>
    CoffeeJournal/Views/Tasting/AttributeSliderView.swift
    CoffeeJournal/Views/Tasting/FlavorTagChipView.swift
    CoffeeJournal/Views/Tasting/FlavorTagFlowView.swift
    CoffeeJournal/Views/Tasting/TastingNoteEntryView.swift
    CoffeeJournal/Views/Brewing/BrewLogDetailView.swift
    CoffeeJournal/Views/Brewing/AddBrewLogView.swift
    Package.swift
  </files>
  <action>
**1. Create AttributeSliderView.swift** -- Reusable 1-5 scale slider:

`struct AttributeSliderView: View` with `let label: String`, `@Binding var value: Int`, `let range: ClosedRange<Int> = 1...5`. Layout: VStack with HStack (label + value text), Slider bound to Double with step 1 and .tint(AppColors.primary), and HStack("Low" / "High" captions in AppColors.subtle). When value is 0 (unrated), show "â€”" instead of the number and position slider at the minimum. Use the pattern from the research document (04-RESEARCH.md AttributeSliderView example).

**2. Create FlavorTagChipView.swift** -- Individual tag chip:

`struct FlavorTagChipView: View` with `let name: String`, `let isSelected: Bool`, `let onTap: () -> Void`, optional `let onRemove: (() -> Void)?` (for custom tags). Capsule shape with text, monochrome styling: selected = filled primary background with background text color, unselected = clear background with primary border. If onRemove is non-nil, show a small "xmark" trailing the name. Use AppTypography.caption for font, AppSpacing.sm horizontal / AppSpacing.xs vertical padding.

**3. Create FlavorTagFlowView.swift** -- Flow layout of flavor tag chips:

`struct FlavorTagFlowView: View` with `let tags: [(id: String, name: String, isCustom: Bool)]`, `let onToggle: (String) -> Void`, `let onRemoveCustom: (String) -> Void`. Use FlowLayout(spacing: 8) to arrange FlavorTagChipView instances. Custom tags show the remove button.

**4. Create TastingNoteEntryView.swift** -- Full tasting note entry form:

`struct TastingNoteEntryView: View` accepting `let brewLog: BrewLog` and `@Environment(\.modelContext) private var modelContext`, `@Environment(\.dismiss) private var dismiss`. Initialize `@State private var viewModel = TastingNoteViewModel()`. In `.onAppear`, if brewLog.tastingNote exists, call viewModel.loadFromTastingNote(brewLog.tastingNote!).

Layout as NavigationStack with Form containing sections:
- **Tasting Attributes** section: Three AttributeSliderViews for Acidity, Body, Sweetness bound to viewModel.acidity, viewModel.bodyRating, viewModel.sweetness
- **Flavor Notes** section: Hierarchical flavor browser -- show FlavorWheel.categories as a List of DisclosureGroups. Each top-level category is a DisclosureGroup that reveals subcategories. Each subcategory is another DisclosureGroup revealing specific descriptors as tappable rows. Tapping a leaf descriptor toggles it in viewModel.selectedFlavorIds. Selected items show a checkmark. This is a simple hierarchical list approach (the radial wheel in Plan 02 will provide the visual alternative).
- **Selected Flavors** section (visible when viewModel.allDisplayTags is non-empty): FlavorTagFlowView showing all selected flavors and custom tags
- **Custom Tags** section: HStack with TextField("Add custom flavor...", text: $viewModel.customTagInput) and Button("Add") calling viewModel.addCustomTag(). Button disabled when customTagInput is empty after trimming.
- **Notes** section: TextEditor bound to viewModel.freeformNotes with 4-line minimum height, placeholder overlay when empty

Toolbar: .navigationTitle("Tasting Notes"), leading Cancel button (dismiss), trailing Save button calling viewModel.save(for: brewLog, in: modelContext) then dismiss. Save button disabled when !viewModel.hasChanges.

**5. Update BrewLogDetailView.swift** -- Add tasting notes section:

After the existing ratingSection, add a new `tastingNotesSection` that:
- If brewLog.tastingNote exists, displays the tasting data: attribute ratings (Acidity/Body/Sweetness as "label: N/5" rows), selected flavor tags as FlavorTagFlowView (read-only, no toggle/remove), freeform notes if non-empty
- Shows a NavigationLink or Button to "Edit Tasting Notes" that navigates to TastingNoteEntryView(brewLog: brew)
- If brewLog.tastingNote is nil, shows a NavigationLink "Add Tasting Notes" to TastingNoteEntryView(brewLog: brew)

**6. Optionally update AddBrewLogView.swift** -- Add a note/hint after the Notes section suggesting "You can add detailed tasting notes after saving this brew." This is a simple Text hint, not a full tasting entry (the entry is accessible from the detail view since tasting notes are typically added after brewing, not during).

**7. Update Package.swift** -- Add the 4 new view files:
- "Views/Tasting/AttributeSliderView.swift"
- "Views/Tasting/FlavorTagChipView.swift"
- "Views/Tasting/FlavorTagFlowView.swift"
- "Views/Tasting/TastingNoteEntryView.swift"
  </action>
  <verify>
Run `swift build` from the project root. All new views compile. Verify:
- TastingNoteEntryView has all 5 form sections (attributes, flavors, selected, custom tags, notes)
- AttributeSliderView accepts @Binding var value: Int
- FlavorTagChipView renders with monochrome capsule styling
- BrewLogDetailView has a tastingNotesSection with navigation to TastingNoteEntryView
- Package.swift includes all new source files
  </verify>
  <done>
Users can navigate from BrewLogDetailView to TastingNoteEntryView, rate acidity/body/sweetness on 1-5 sliders, browse hierarchical flavor categories, toggle flavor selections, add custom tags, write freeform notes, and save. Tasting data persists via SwiftData with iCloud sync through the existing CloudKit configuration.
  </done>
</task>

</tasks>

<verification>
1. BrewLog model has `@Relationship(inverse: \TastingNote.brewLog) var tastingNote: TastingNote?`
2. FlavorWheel.categories contains 9 top-level nodes with subcategories and leaf descriptors
3. TastingNoteEntryView displays 3 attribute sliders (Acidity, Body, Sweetness) on 1-5 scale
4. Flavor selection via hierarchical DisclosureGroup list works -- selecting a leaf adds it to viewModel.selectedFlavorIds
5. Custom tags can be added via text input and appear in the FlavorTagFlowView
6. Saving creates/updates a TastingNote linked to the BrewLog with JSON-encoded flavorTags
7. BrewLogDetailView shows existing tasting data and links to add/edit
8. All new files added to Package.swift and project compiles with `swift build`
</verification>

<success_criteria>
- AttributeSliderView provides discrete 1-5 ratings for acidity, body, and sweetness
- Flavor tags can be selected from hierarchical SCA categories and custom tags can be added
- TastingNote saves to SwiftData with JSON-encoded flavorTags string (CloudKit-safe)
- BrewLogDetailView displays tasting note data and provides navigation to entry/edit
- BrewLog <-> TastingNote inverse relationship established for CloudKit sync
</success_criteria>

<output>
After completion, create `.planning/phases/04-tasting-flavor-notes/04-01-SUMMARY.md`
</output>
