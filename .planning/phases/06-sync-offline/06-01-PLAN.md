---
phase: 06-sync-offline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CoffeeJournal/Services/SyncMonitor.swift
  - CoffeeJournal/Services/NetworkMonitor.swift
  - CoffeeJournal/Views/Components/SyncStatusView.swift
  - CoffeeJournal/Views/Settings/SettingsView.swift
  - CoffeeJournal/CoffeeJournalApp.swift
  - Package.swift
autonomous: false

must_haves:
  truths:
    - "App works fully offline -- user can create, edit, and delete data with no network connection and changes persist locally"
    - "When connectivity returns after being offline, data syncs automatically without user intervention"
    - "User can see current sync status (syncing, up to date, offline, error, no iCloud account) in the Settings screen"
    - "When the device is offline, a subtle indicator informs the user without blocking interaction"
    - "If user is not signed into iCloud, the Settings Data section shows a clear message explaining sync is unavailable"
    - "Photos are compressed before storage (already implemented) and sync as CloudKit assets within the 50MB limit"
    - "When the same record is edited on two offline devices and both reconnect, CloudKit's last-writer-wins resolves the conflict without crash or data corruption -- the most recent save persists and no records are lost"
  artifacts:
    - path: "CoffeeJournal/Services/SyncMonitor.swift"
      provides: "@Observable class monitoring CloudKit sync events via NSPersistentCloudKitContainer.eventChangedNotification"
      contains: "eventChangedNotification"
    - path: "CoffeeJournal/Services/NetworkMonitor.swift"
      provides: "@Observable class wrapping NWPathMonitor for real-time connectivity state"
      contains: "NWPathMonitor"
    - path: "CoffeeJournal/Views/Components/SyncStatusView.swift"
      provides: "SyncStatusSection for Settings and OfflineBanner for toolbar overlay"
      contains: "SyncStatusSection"
    - path: "CoffeeJournal/Views/Settings/SettingsView.swift"
      provides: "Enhanced Settings with live sync status section replacing static 'Enabled' text"
      contains: "SyncStatusSection"
    - path: "CoffeeJournal/CoffeeJournalApp.swift"
      provides: "SyncMonitor and NetworkMonitor initialized at app level and injected into environment"
      contains: ".environment(syncMonitor)"
  key_links:
    - from: "CoffeeJournalApp.swift"
      to: "SyncMonitor.swift"
      via: "@State private var syncMonitor = SyncMonitor() injected into environment"
      pattern: "environment\\(syncMonitor\\)"
    - from: "CoffeeJournalApp.swift"
      to: "NetworkMonitor.swift"
      via: "@State private var networkMonitor = NetworkMonitor() injected into environment"
      pattern: "environment\\(networkMonitor\\)"
    - from: "SyncStatusView.swift"
      to: "SyncMonitor.swift"
      via: "@Environment(SyncMonitor.self) reads sync state for icon/text display"
      pattern: "@Environment\\(SyncMonitor\\.self\\)"
    - from: "SyncStatusView.swift"
      to: "NetworkMonitor.swift"
      via: "@Environment(NetworkMonitor.self) reads connectivity for offline banner"
      pattern: "@Environment\\(NetworkMonitor\\.self\\)"
    - from: "SettingsView.swift"
      to: "SyncStatusView.swift"
      via: "SyncStatusSection() replaces static Data section"
      pattern: "SyncStatusSection\\(\\)"
---

<objective>
Build the sync monitoring and offline awareness layer for the app. Create SyncMonitor (@Observable, listens to CloudKit sync events), NetworkMonitor (@Observable, wraps NWPathMonitor), and sync status UI components. Wire everything into the app at startup and enhance the Settings screen with live sync status.

Purpose: This makes the existing SwiftData+CloudKit sync *visible* to users. The infrastructure already syncs automatically -- Phase 6 observes that behavior and surfaces it. Users know when they're offline, when sync succeeds/fails, and when iCloud is unavailable.

Output: 2 service classes, 1 view component file, 2 modified files (app entry point, settings), updated Package.swift.
</objective>

<execution_context>
@/Users/ashok/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-sync-offline/06-RESEARCH.md
@CoffeeJournal/CoffeeJournalApp.swift
@CoffeeJournal/Views/Settings/SettingsView.swift
@CoffeeJournal/Utilities/ImageCompressor.swift
@CoffeeJournal/Views/Components/MonochromeStyle.swift
@Package.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncMonitor and NetworkMonitor service classes</name>
  <files>
    CoffeeJournal/Services/SyncMonitor.swift
    CoffeeJournal/Services/NetworkMonitor.swift
  </files>
  <action>
Create `CoffeeJournal/Services/` directory.

**SyncMonitor.swift:**

Create an `@Observable` class that monitors CloudKit sync events and iCloud account status.

1. Import `SwiftData`, `CoreData` (for `NSPersistentCloudKitContainer.eventChangedNotification` and `NSPersistentCloudKitContainer.Event`), `CloudKit` (for `CKContainer.accountStatus()`), and `Observation`.

2. Define `SyncState` enum inside the class:
   ```swift
   enum SyncState: Equatable {
       case idle
       case syncing
       case succeeded
       case failed(String)
       case noAccount
   }
   ```

3. Properties:
   - `private(set) var importState: SyncState = .idle`
   - `private(set) var exportState: SyncState = .idle`
   - `private(set) var lastSuccessfulSync: Date?`

4. Computed property `overallState: SyncState`:
   - If either state is `.failed`, return the failed state.
   - If either state is `.noAccount`, return `.noAccount`.
   - If either state is `.syncing`, return `.syncing`.
   - If both are `.succeeded`, return `.succeeded`.
   - Otherwise return `.idle`.

5. In `init()`:
   - Subscribe to `NSPersistentCloudKitContainer.eventChangedNotification` via `NotificationCenter.default.addObserver(forName:object:queue:)` on `.main` queue. Use `[weak self]` in the closure.
   - Subscribe to `Notification.Name.CKAccountChanged` to detect iCloud sign-in/sign-out at runtime. In the handler, call `Task { await self?.checkAccountStatus() }`.

6. Private method `handleEvent(_ notification: Notification)`:
   - Extract the event: `guard let event = notification.userInfo?[NSPersistentCloudKitContainer.eventNotificationUserInfoKey] as? NSPersistentCloudKitContainer.Event else { return }`
   - Determine if finished: `let isFinished = event.endDate != nil`
   - Compute state: if `event.error != nil`, state is `.failed(event.error!.localizedDescription)`; if finished, `.succeeded`; otherwise `.syncing`.
   - Switch on `event.type`: `.import` updates `importState`, `.export` updates `exportState`, `.setup` is ignored, `@unknown default` is ignored.
   - If finished and no error, update `lastSuccessfulSync = Date()`.

7. Method `func checkAccountStatus() async`:
   - Call `try await CKContainer.default().accountStatus()`.
   - Switch on result:
     - `.available`: do nothing (sync is possible).
     - `.noAccount`, `.restricted`: set both `importState` and `exportState` to `.noAccount`.
     - `.couldNotDetermine`, `.temporarilyUnavailable`: do nothing (treat as potentially available).
     - `@unknown default`: do nothing.
   - Catch errors: set `importState` to `.failed(error.localizedDescription)`.

**NetworkMonitor.swift:**

Create an `@Observable` class wrapping `NWPathMonitor`.

1. Import `Network` and `Observation`.

2. Properties:
   - `private let monitor = NWPathMonitor()`
   - `private let queue = DispatchQueue(label: "com.coffeejournal.networkmonitor")`
   - `private(set) var isConnected: Bool = true`
   - `private(set) var connectionType: ConnectionType = .unknown`

3. Define `ConnectionType` enum: `.wifi`, `.cellular`, `.wiredEthernet`, `.unknown`.

4. In `init()`:
   - Set `monitor.pathUpdateHandler` to a closure with `[weak self]` that dispatches to `DispatchQueue.main.async`:
     - `self?.isConnected = path.status == .satisfied`
     - `self?.connectionType = self?.getConnectionType(path) ?? .unknown`
   - Call `monitor.start(queue: queue)`.

5. Private method `getConnectionType(_ path: NWPath) -> ConnectionType`:
   - Check interface types in order: `.wifi` -> `.cellular` -> `.wiredEthernet` -> return `.unknown`.

6. `deinit`: call `monitor.cancel()`.

**Key constraints:**
- Both classes use `@Observable` (iOS 17+), NOT `ObservableObject`/`@Published`.
- No external dependencies -- only Apple frameworks.
- SyncMonitor imports CoreData solely for the notification constant and event type -- this is stable API.
  </action>
  <verify>
`swift build` succeeds from project root (after adding files to Package.swift in Task 2). Both files compile with no errors. SyncMonitor subscribes to eventChangedNotification. NetworkMonitor wraps NWPathMonitor.
  </verify>
  <done>
SyncMonitor class exists that listens to CloudKit sync events and iCloud account changes, exposing importState/exportState/overallState/lastSuccessfulSync as observable properties. NetworkMonitor class exists that wraps NWPathMonitor, exposing isConnected and connectionType as observable properties.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sync status UI, wire into app and Settings, update Package.swift</name>
  <files>
    CoffeeJournal/Views/Components/SyncStatusView.swift
    CoffeeJournal/Views/Settings/SettingsView.swift
    CoffeeJournal/CoffeeJournalApp.swift
    Package.swift
  </files>
  <action>
**SyncStatusView.swift -- Sync status components:**

Create in `CoffeeJournal/Views/Components/`.

1. `SyncStatusSection: View` -- a Form Section for Settings:
   - `@Environment(SyncMonitor.self) private var syncMonitor`
   - `@Environment(NetworkMonitor.self) private var networkMonitor`
   - Body: A `Section` with header "Data":
     - Primary row: `HStack` with `Label("iCloud Sync", systemImage: syncIconName)` (icon uses `.foregroundStyle(syncIconColor)`), `Spacer()`, `Text(syncStatusText).foregroundStyle(AppColors.subtle)`.
     - If `!networkMonitor.isConnected`: Show a `Label` with text "You're offline. Changes will sync when connected." using `AppTypography.caption` and `AppColors.subtle`, icon `wifi.slash` with `AppColors.muted`.
     - If `case .noAccount = syncMonitor.overallState`: Show a `Label` with text "Sign in to iCloud in Settings to sync across devices." using `AppTypography.caption` and `AppColors.subtle`, icon `exclamationmark.icloud` with `AppColors.muted`.
   - Footer: If `syncMonitor.lastSuccessfulSync` is non-nil, show `Text("Last synced \(lastSync, style: .relative) ago")`.

   Private computed properties:
   - `syncIconName: String` -- switch on `syncMonitor.overallState`:
     - `.idle` -> `"icloud"`
     - `.syncing` -> `"arrow.triangle.2.circlepath.icloud"`
     - `.succeeded` -> `"checkmark.icloud"`
     - `.failed` -> `"exclamationmark.icloud"`
     - `.noAccount` -> `"xmark.icloud"`
   - `syncIconColor: Color` -- `.failed` or `.noAccount` -> `AppColors.primary`, default -> `AppColors.subtle`
   - `syncStatusText: String`:
     - If `!networkMonitor.isConnected` -> `"Offline"`
     - Otherwise switch on overallState: `.idle` -> `"Enabled"`, `.syncing` -> `"Syncing..."`, `.succeeded` -> `"Up to date"`, `.failed` -> `"Error"`, `.noAccount` -> `"Not signed in"`

2. `OfflineBanner: View` -- a compact capsule banner:
   - `@Environment(NetworkMonitor.self) private var networkMonitor`
   - Body: If `!networkMonitor.isConnected`, show `HStack(spacing: 8)` with `Image(systemName: "wifi.slash")` and `Text("Offline mode").font(AppTypography.caption)`, foregroundStyle `AppColors.subtle`, padded, background `AppColors.secondaryBackground`, clipped to `Capsule()`.

**SettingsView.swift -- Replace static Data section:**

1. Read from `@Environment(SyncMonitor.self)` and `@Environment(NetworkMonitor.self)` -- NO, these are used inside `SyncStatusSection` which reads them directly. SettingsView just needs to embed `SyncStatusSection()`.

2. Replace the entire existing static `Section { ... } header: { Text("Data") } footer: { ... }` block (the one with hardcoded "iCloud Sync" / "Enabled") with a single call to `SyncStatusSection()`.

3. Keep the Equipment Setup section and About section unchanged.

4. Add `.task { }` modifier to the Form that calls `await syncMonitor.checkAccountStatus()`. This requires adding `@Environment(SyncMonitor.self) private var syncMonitor` to SettingsView.

**CoffeeJournalApp.swift -- Initialize and inject monitors:**

1. Add `import CoreData` (needed transitively through SyncMonitor, but SyncMonitor handles its own imports -- not needed here unless compiler requires). Add `import CloudKit` if needed. Actually, the App file only needs to create the instances and inject them -- no CoreData/CloudKit imports needed in the App file itself.

2. Add two `@State` properties:
   - `@State private var syncMonitor = SyncMonitor()`
   - `@State private var networkMonitor = NetworkMonitor()`

3. In the `body` scene, chain `.environment(syncMonitor)` and `.environment(networkMonitor)` on the `ContentView()`:
   ```swift
   WindowGroup {
       ContentView()
           .environment(syncMonitor)
           .environment(networkMonitor)
   }
   .modelContainer(container)
   ```

**Package.swift -- Add new source files:**

Add these entries to the Package.swift sources array (after the existing Utilities entries for logical grouping):
- `"Services/SyncMonitor.swift"`
- `"Services/NetworkMonitor.swift"`
- `"Views/Components/SyncStatusView.swift"`

The existing SettingsView.swift and CoffeeJournalApp.swift should already be in the sources list.

Run `swift build` to verify the entire project compiles.

**Design constraints:**
- All text/icons use monochrome styling (AppColors.primary, AppColors.subtle, AppColors.muted) -- no blue, no color.
- Sync status is non-intrusive: detailed info in Settings, minimal elsewhere.
- Follow Apple's pattern: show sync status primarily in Settings, not a persistent banner during normal operation.
- The OfflineBanner is available for use but NOT wired into MainTabView by default. It's a component that can be added to specific views if desired. The Settings sync section is the primary user-facing indicator.
  </action>
  <verify>
`swift build` succeeds from project root. SettingsView renders SyncStatusSection instead of static text. CoffeeJournalApp injects both monitors into environment. SyncStatusSection reads from both environment objects and displays appropriate icon/text.
  </verify>
  <done>
SyncStatusSection component renders live sync status with appropriate SF Symbol icons and status text in Settings. OfflineBanner component available for offline indication. SettingsView shows real-time sync state instead of hardcoded "Enabled". CoffeeJournalApp initializes SyncMonitor and NetworkMonitor as @State and injects them into the SwiftUI environment via .environment() modifiers. Package.swift includes all new files and builds successfully.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify SYNC-04 conflict resolution on two physical devices</name>
  <what-built>
SwiftData+CloudKit automatic conflict resolution (last-writer-wins at the record level). This is NOT custom code -- it is CloudKit's built-in behavior via NSPersistentCloudKitContainer. All models already have `updatedAt: Date` fields that track when records were last modified, which helps identify which version persisted after a conflict.

Per Phase 6 research: CloudKit uses last-writer-wins at the entity (record) level, not field-level merge. Two changes to different properties of the same record will NOT be merged -- the most recent full-record save wins. For a personal coffee journal app with 1-2 devices, simultaneous offline edits to the same record are rare, making this acceptable.
  </what-built>
  <how-to-verify>
**Prerequisites:** Two physical iOS devices signed into the SAME iCloud account, with the app installed on both. (Simulator cannot test real CloudKit sync because it does not support APNs push notifications.)

**Test 1 -- Basic cross-device sync (happy path):**
1. On Device A: Create a new brew log entry with distinctive data (e.g., "Sync Test Brew")
2. Wait 30-60 seconds
3. On Device B: Verify the brew log appears with all data intact
4. Expected: Record syncs correctly to Device B

**Test 2 -- Offline edit, reconnect sync:**
1. On Device A: Enable Airplane Mode
2. On Device A: Edit an existing brew log's notes to "Edited offline on A"
3. On Device A: Disable Airplane Mode
4. Wait 30-60 seconds
5. On Device B: Verify the edit appears
6. Expected: Offline edit syncs when connectivity returns

**Test 3 -- Conflict scenario (both devices offline, edit same record):**
1. On BOTH devices: Enable Airplane Mode
2. On Device A: Edit a brew log's notes to "Version A"
3. On Device B: Edit the SAME brew log's notes to "Version B"
4. On Device A: Disable Airplane Mode, wait 30 seconds
5. On Device B: Disable Airplane Mode, wait 30 seconds
6. Wait 60 seconds for sync to settle
7. Check BOTH devices: The notes field should show the SAME value on both (whichever was the last-writer-wins)
8. Expected: No crash, no data corruption, no duplicate records. One version wins. The `updatedAt` timestamp reflects the winning edit. The other device's edit is silently overwritten.

**Test 4 -- Verify no data loss on other records:**
1. After Test 3, verify other brew logs, beans, and equipment are unaffected
2. Expected: Conflict resolution only affects the contested record, not the entire dataset

**Verification of sync status UI (combines with Tasks 1-2):**
- During Test 2, verify Settings shows "Offline" while in Airplane Mode
- After reconnecting, verify Settings shows "Syncing..." briefly, then "Up to date"
- Verify "Last synced X ago" footer updates after successful sync
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues observed (crashes, missing data, unexpected behavior)</resume-signal>
</task>

</tasks>

<verification>
1. `swift build` passes with 0 errors from project root
2. SyncMonitor subscribes to NSPersistentCloudKitContainer.eventChangedNotification and exposes overallState
3. NetworkMonitor wraps NWPathMonitor and exposes isConnected
4. CoffeeJournalApp creates both monitors as @State and injects via .environment()
5. SettingsView displays SyncStatusSection with dynamic sync icon, status text, offline message, and no-account message
6. SyncStatusSection replaces the old hardcoded "iCloud Sync: Enabled" text
7. SyncMonitor checks CKContainer.accountStatus() on Settings appear
8. Photo compression already exists (ImageCompressor at 1024px/0.7 quality) -- no changes needed for SYNC-05
9. All UI follows monochrome design constraint (AppColors.primary, .subtle, .muted)
10. SYNC-04 conflict resolution verified on two physical devices: editing the same record offline on both devices, then reconnecting, results in last-writer-wins with no crash, no data corruption, and no duplicate records
</verification>

<success_criteria>
- SyncMonitor listens to CloudKit sync events and reports import/export/overall state
- NetworkMonitor detects connectivity changes in real-time via NWPathMonitor
- Settings Data section shows live sync status: icon + text + optional offline/no-account messages
- Settings footer shows "Last synced X ago" when a successful sync has occurred
- When offline, Settings shows "Offline" status with explanatory message
- When not signed into iCloud, Settings shows "Not signed in" with sign-in guidance
- Both monitors are injected at app startup and available to any view in the hierarchy
- Photo compression for CloudKit assets is already handled by existing ImageCompressor
- All new UI uses monochrome design tokens only
- Conflict resolution (SYNC-04) verified: editing the same record on two offline devices, then reconnecting, resolves via CloudKit last-writer-wins without crash, data corruption, or duplicate records
</success_criteria>

<output>
After completion, create `.planning/phases/06-sync-offline/06-01-SUMMARY.md`
</output>
