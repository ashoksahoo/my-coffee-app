---
phase: 01-foundation-equipment
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - CoffeeJournal/Views/Equipment/MethodListView.swift
  - CoffeeJournal/Views/Equipment/GrinderListView.swift
  - CoffeeJournal/Views/Equipment/AddMethodView.swift
  - CoffeeJournal/Views/Equipment/AddGrinderView.swift
autonomous: true

must_haves:
  truths:
    - "User can see a list of their brew methods sorted by last used"
    - "User can see a list of their grinders sorted by last used"
    - "User can add a new brew method from the curated template list"
    - "User can add a new grinder with name, type, and setting range"
    - "User can delete equipment via swipe action"
    - "User sees an empty state with call-to-action when no equipment exists"
    - "Usage statistics (brew count, last used) appear inline in list rows"
  artifacts:
    - path: "CoffeeJournal/Views/Equipment/MethodListView.swift"
      provides: "Methods list screen with @Query, sort, swipe delete, empty state"
      contains: "@Query"
    - path: "CoffeeJournal/Views/Equipment/GrinderListView.swift"
      provides: "Grinders list screen with @Query, sort, swipe delete, empty state"
      contains: "@Query"
    - path: "CoffeeJournal/Views/Equipment/AddMethodView.swift"
      provides: "Add method sheet with template selection"
      contains: "MethodTemplate"
    - path: "CoffeeJournal/Views/Equipment/AddGrinderView.swift"
      provides: "Add grinder sheet with name, type, setting range"
      contains: "Grinder"
  key_links:
    - from: "MethodListView.swift"
      to: "BrewMethod.swift"
      via: "@Query fetches BrewMethod from SwiftData"
      pattern: "@Query.*BrewMethod"
    - from: "GrinderListView.swift"
      to: "Grinder.swift"
      via: "@Query fetches Grinder from SwiftData"
      pattern: "@Query.*Grinder"
    - from: "MethodListView.swift"
      to: "EquipmentRow.swift"
      via: "List rows use EquipmentRow component"
      pattern: "EquipmentRow"
    - from: "AddMethodView.swift"
      to: "BrewMethod.swift"
      via: "Creates BrewMethod from template and inserts to modelContext"
      pattern: "modelContext\\.insert"
---

<objective>
Build the two primary equipment list screens (Methods and Grinders) with add, delete, sort, and empty state functionality. These are the main screens users interact with after setup. Per user decision: two separate screens (not tabs, not single list).

Purpose: Equipment lists are the core browsing experience for Phase 1. Users need to see, add, and remove equipment with inline usage stats. This is where the @Query + SwiftData pattern is proven for the first time.
Output: MethodListView, GrinderListView, AddMethodView, AddGrinderView -- all with SwiftData integration and monochrome styling.
</objective>

<execution_context>
@/Users/ashok/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-equipment/01-RESEARCH.md
@.planning/phases/01-foundation-equipment/01-CONTEXT.md
@.planning/phases/01-foundation-equipment/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MethodListView and AddMethodView</name>
  <files>
    CoffeeJournal/Views/Equipment/MethodListView.swift
    CoffeeJournal/Views/Equipment/AddMethodView.swift
  </files>
  <action>
    1. **MethodListView.swift** -- The methods screen:
       - Use `@Query(sort: \BrewMethod.lastUsedDate, order: .reverse)` to fetch brew methods sorted by most recently used first (per Claude's discretion: auto-sort by last used). Methods that have never been used (nil lastUsedDate) should appear at the end -- handle this with a secondary sort on `createdAt`.
       - `@Environment(\.modelContext) private var modelContext`
       - `@State private var showingAddSheet = false`
       - Render a `List` with `ForEach(methods)`. Each row uses `EquipmentRow` component passing: `name: method.name`, `subtitle: method.category.displayName` (add a `displayName` computed property to MethodCategory that returns human-readable names like "Pour Over", "Espresso", "Immersion"), `iconName: method.category.iconName` (add SF Symbol mapping: espresso = "cup.and.saucer.fill", pourOver = "drop.fill", immersion = "timer", other = "mug.fill"), `photoData: method.photoData`, `brewCount: method.brewCount`, `lastUsedDate: method.lastUsedDate`.
       - Each row is a `NavigationLink` that navigates to MethodDetailView (will be created in Plan 04, for now use a placeholder destination Text view showing the method name).
       - Trailing swipe action: delete with confirmation (red destructive button with trash icon). Delete calls `modelContext.delete(method)`.
       - Toolbar: trailing "+" button that presents AddMethodView as a sheet.
       - When `methods.isEmpty`, show `EmptyStateView(systemImage: "cup.and.saucer", title: "No Brew Methods", message: "Add your first brew method to get started", action: { showingAddSheet = true }, actionLabel: "Add Method")`.
       - Navigation title: "Methods"
       - Monochrome styling throughout.

    2. **AddMethodView.swift** -- Sheet for adding a new method:
       - `@Environment(\.modelContext) private var modelContext`
       - `@Environment(\.dismiss) private var dismiss`
       - Shows the curated `MethodTemplate.allMethods` list (same templates from the setup wizard).
       - Each template row shows: SF Symbol icon for category, method name, category subtitle.
       - Tapping a template creates a `BrewMethod(from: template)`, inserts it into modelContext, and dismisses the sheet.
       - Also include a "Custom Method" option at the bottom that presents a form with: TextField for name, Picker for MethodCategory. On save, creates BrewMethod with entered name and selected category.
       - Navigation title: "Add Brew Method"
       - Cancel button in toolbar leading position.
       - Monochrome styling.
  </action>
  <verify>
    Run `xcodebuild build` and confirm MethodListView and AddMethodView compile. Verify MethodListView uses @Query to fetch BrewMethod. Verify AddMethodView creates and inserts BrewMethod into modelContext. Verify EquipmentRow is used for list rows.
  </verify>
  <done>
    MethodListView displays brew methods sorted by last used, with EquipmentRow showing inline stats (brew count, last used), swipe-to-delete, empty state, and "+" to add. AddMethodView allows selecting from curated templates or creating custom methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GrinderListView and AddGrinderView</name>
  <files>
    CoffeeJournal/Views/Equipment/GrinderListView.swift
    CoffeeJournal/Views/Equipment/AddGrinderView.swift
  </files>
  <action>
    1. **GrinderListView.swift** -- The grinders screen:
       - Use `@Query(sort: \Grinder.lastUsedDate, order: .reverse)` to fetch grinders sorted by most recently used first. Handle nil lastUsedDate same as MethodListView (secondary sort on createdAt).
       - `@Environment(\.modelContext) private var modelContext`
       - `@State private var showingAddSheet = false`
       - Render a `List` with `ForEach(grinders)`. Each row uses `EquipmentRow` component passing: `name: grinder.name`, `subtitle: grinder.grinderType.displayName` (add displayName to GrinderType: "Burr Grinder", "Blade Grinder", "Manual Grinder"), `iconName: grinder.grinderType.iconName` (SF Symbols: burr = "gearshape.2.fill", blade = "bolt.fill", manual = "hand.draw.fill"), `photoData: grinder.photoData`, `brewCount: grinder.brewCount`, `lastUsedDate: grinder.lastUsedDate`.
       - Each row is a `NavigationLink` that navigates to GrinderDetailView (Plan 04, use placeholder for now).
       - Trailing swipe action: delete with confirmation (red destructive button).
       - Toolbar: trailing "+" button presents AddGrinderView as sheet.
       - When `grinders.isEmpty`, show `EmptyStateView(systemImage: "gearshape", title: "No Grinders", message: "Add your first grinder to get started", action: { showingAddSheet = true }, actionLabel: "Add Grinder")`.
       - Navigation title: "Grinders"
       - Monochrome styling.

    2. **AddGrinderView.swift** -- Sheet for adding a new grinder:
       - `@Environment(\.modelContext) private var modelContext`
       - `@Environment(\.dismiss) private var dismiss`
       - Form with:
         - TextField for grinder name (required, save button disabled if empty)
         - Picker for GrinderType (burr, blade, manual)
         - Section "Setting Range" with:
           - TextField or Stepper for minimum setting (Double, default 0)
           - TextField or Stepper for maximum setting (Double, default 40)
           - TextField or Stepper for step increment (Double, default 1)
         - Optional TextField for notes
       - Toolbar: leading "Cancel" button (dismiss), trailing "Save" button.
       - Save creates `Grinder(name: name, type: selectedType)`, sets settingMin/Max/Step from form values, inserts into modelContext, dismisses.
       - Navigation title: "Add Grinder"
       - Monochrome styling.
  </action>
  <verify>
    Run `xcodebuild build` and confirm GrinderListView and AddGrinderView compile. Verify GrinderListView uses @Query to fetch Grinder. Verify AddGrinderView creates Grinder with name, type, and setting range, then inserts into modelContext.
  </verify>
  <done>
    GrinderListView displays grinders sorted by last used, with EquipmentRow showing inline stats, swipe-to-delete, empty state, and "+" to add. AddGrinderView captures grinder name, type, and setting range.
  </done>
</task>

</tasks>

<verification>
- `xcodebuild build` succeeds with zero errors
- MethodListView and GrinderListView are separate screens (per user decision)
- Both lists use @Query for SwiftData integration
- Both lists use EquipmentRow for consistent row rendering
- Both lists show inline usage stats (brew count, last used)
- Swipe-to-delete works on both lists (iOS standard pattern per discretion)
- Empty states shown when no equipment exists
- Add sheets allow creating new equipment
- All monochrome styling
</verification>

<success_criteria>
- Two separate equipment list screens exist and display SwiftData content
- Users can add and delete brew methods and grinders
- Empty states guide users to add first equipment
- Usage statistics visible inline in list rows
- Monochrome design constraint honored throughout
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-equipment/01-03-SUMMARY.md`
</output>
