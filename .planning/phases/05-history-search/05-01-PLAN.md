---
phase: 05-history-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CoffeeJournal/Views/Brewing/BrewLogListView.swift
  - CoffeeJournal/Views/History/BrewHistoryListContent.swift
  - CoffeeJournal/Views/History/BrewFilterSheet.swift
  - Package.swift
autonomous: true

must_haves:
  truths:
    - "User can scroll through a chronological list of all brew logs (newest first)"
    - "User can type in a search bar to filter brews by notes text"
    - "User can filter brews by method, coffee bean, date range, and minimum rating via a filter sheet"
    - "User can combine multiple filter criteria simultaneously (e.g., method + date range + rating)"
    - "User can see a visual indicator when any filter is active"
    - "User can clear all filters to return to the full brew list"
  artifacts:
    - path: "CoffeeJournal/Views/Brewing/BrewLogListView.swift"
      provides: "Parent view with search text state, filter state, .searchable modifier, filter sheet presentation, toolbar with filter icon"
      contains: "searchable"
    - path: "CoffeeJournal/Views/History/BrewHistoryListContent.swift"
      provides: "Child view with dynamic @Query using #Predicate for scalar filters + in-memory post-filter for relationships"
      contains: "#Predicate"
    - path: "CoffeeJournal/Views/History/BrewFilterSheet.swift"
      provides: "Modal filter form with method picker, bean picker, date range, minimum rating, clear all button"
      contains: "BrewFilterSheet"
  key_links:
    - from: "BrewLogListView.swift"
      to: "BrewHistoryListContent.swift"
      via: "Parent passes filter state (searchText, methodID, beanID, startDate, endDate, minimumRating) to child init"
      pattern: "BrewHistoryListContent\\("
    - from: "BrewLogListView.swift"
      to: "BrewFilterSheet.swift"
      via: "Sheet presentation with @Binding for all filter parameters"
      pattern: "BrewFilterSheet\\("
    - from: "BrewHistoryListContent.swift"
      to: "BrewLog"
      via: "@Query with #Predicate for scalar filters, computed filteredBrews for relationship post-filter"
      pattern: "filteredBrews"
---

<objective>
Refactor the existing BrewLogListView into a parent/child @Query pattern with multi-criteria filtering and search. This delivers HIST-01 (chronological brew list), HIST-02 (filter by coffee/method/date), and HIST-03 (advanced multi-criteria search).

Purpose: Transform the static brew list into a filterable, searchable history view -- the core of Phase 5. The existing BrewLogDetailView already satisfies HIST-04 and HIST-05, so this plan focuses on the list/filter layer.

Output: Refactored BrewLogListView with .searchable, BrewHistoryListContent with dynamic @Query, and BrewFilterSheet for advanced filters.
</objective>

<execution_context>
@/Users/ashok/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CoffeeJournal/Views/Brewing/BrewLogListView.swift
@CoffeeJournal/Views/Beans/BeanListView.swift
@CoffeeJournal/Models/BrewLog.swift
@CoffeeJournal/Views/Brewing/BrewLogRow.swift
@CoffeeJournal/Views/Brewing/BrewLogDetailView.swift
@CoffeeJournal/Views/Components/MonochromeStyle.swift
@CoffeeJournal/Views/Components/EmptyStateView.swift
@Package.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor BrewLogListView parent and create BrewHistoryListContent child</name>
  <files>
    CoffeeJournal/Views/Brewing/BrewLogListView.swift
    CoffeeJournal/Views/History/BrewHistoryListContent.swift
  </files>
  <action>
**BrewLogListView.swift -- Refactor into parent with filter state:**

1. Add `@State` properties for all filter criteria:
   - `searchText: String = ""`
   - `selectedMethodID: PersistentIdentifier? = nil`
   - `selectedBeanID: PersistentIdentifier? = nil`
   - `startDate: Date? = nil`
   - `endDate: Date? = nil`
   - `minimumRating: Int = 0`
   - `showingFilterSheet: Bool = false`
   - `showingAddSheet: Bool = false` (already exists)

2. Add a computed property `hasActiveFilters: Bool` that returns `true` if any filter is non-default (any of: selectedMethodID != nil, selectedBeanID != nil, startDate != nil, endDate != nil, minimumRating > 0, !searchText.isEmpty).

3. Replace `BrewLogListContent()` with `BrewHistoryListContent(searchText:methodID:beanID:startDate:endDate:minimumRating:)` passing all filter state.

4. Add `.searchable(text: $searchText, prompt: "Search brew notes")` modifier.

5. Update the toolbar:
   - Keep the existing Compare button (topBarLeading).
   - Keep the existing + button (topBarTrailing).
   - Add a filter button (topBarTrailing) that toggles `showingFilterSheet`. Use `Image(systemName: hasActiveFilters ? "line.3.horizontal.decrease.circle.fill" : "line.3.horizontal.decrease.circle")` with `.foregroundStyle(AppColors.primary)`.

6. Add `.sheet(isPresented: $showingFilterSheet)` presenting `BrewFilterSheet(selectedMethodID:selectedBeanID:startDate:endDate:minimumRating:)` with `$` bindings.

7. Remove the old `BrewLogListContent` struct from this file entirely (it moves to BrewHistoryListContent.swift).

**BrewHistoryListContent.swift -- New child view with dynamic @Query:**

Create `CoffeeJournal/Views/History/` directory and new file.

1. Import SwiftUI and SwiftData.

2. Create `struct BrewHistoryListContent: View` with:
   - `@Query private var brews: [BrewLog]`
   - `@Environment(\.modelContext) private var modelContext`
   - Stored properties: `let methodID: PersistentIdentifier?` and `let beanID: PersistentIdentifier?`

3. In `init(searchText:methodID:beanID:startDate:endDate:minimumRating:)`:
   - Store `methodID` and `beanID` as instance properties (for in-memory post-filtering).
   - Capture all scalar filter values as local `let` constants before the `#Predicate` (required to avoid multi-component keypath errors):
     ```swift
     let search = searchText
     let minRating = minimumRating
     let sDate = startDate
     let eDate = endDate
     ```
   - Initialize `_brews = Query(filter: #Predicate<BrewLog> { brew in ... }, sort: [SortDescriptor(\BrewLog.createdAt, order: .reverse)])`.
   - Predicate logic (all conditions AND'd):
     - Text search: `(search.isEmpty || brew.notes.localizedStandardContains(search))`
     - Rating: `brew.rating >= minRating`
     - Start date: `(sDate == nil || brew.createdAt >= sDate!)`
     - End date: `(eDate == nil || brew.createdAt <= eDate!)`

4. Add `private var filteredBrews: [BrewLog]` computed property that applies in-memory relationship filtering on `brews`:
   - If `methodID` is non-nil, filter to brews where `brew.brewMethod?.persistentModelID == mID`.
   - If `beanID` is non-nil, filter to brews where `brew.coffeeBean?.persistentModelID == bID`.
   - If both are nil, return `brews` as-is (no Array copy overhead -- use `Array(brews)` or just iterate `brews`).

5. Body: If `filteredBrews.isEmpty`, show `EmptyStateView(systemImage: "magnifyingglass", title: "No Matches", message: "Try adjusting your filters or search text")`. Otherwise show a `List` with `ForEach(filteredBrews)` containing `NavigationLink` to `BrewLogDetailView(brew:)` with `BrewLogRow(brew:)` label and the existing swipe-to-delete action.

**Key patterns to follow:**
- Follow the BeanListView/BeanListContent parent/child @Query pattern exactly.
- Use the hybrid predicate approach: `#Predicate` for scalars, in-memory for relationships. Do NOT attempt to compare `persistentModelID` inside `#Predicate` -- it's fragile with optional relationships.
- All filter state owned by parent, passed to child as init parameters. Child reinitializes @Query on every state change.
  </action>
  <verify>
Build succeeds with `swift build` from project root. BrewLogListView compiles with .searchable modifier. BrewHistoryListContent compiles with #Predicate and filteredBrews computed property.
  </verify>
  <done>
BrewLogListView is a parent view with search + filter state that passes all criteria to BrewHistoryListContent. The child view uses #Predicate for scalar filtering and in-memory post-filter for method/bean relationships. The brew list displays chronologically with search bar visible.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BrewFilterSheet for advanced multi-criteria filters</name>
  <files>
    CoffeeJournal/Views/History/BrewFilterSheet.swift
  </files>
  <action>
Create `BrewFilterSheet.swift` in `CoffeeJournal/Views/History/`.

1. Import SwiftUI and SwiftData.

2. Create `struct BrewFilterSheet: View` with @Binding parameters:
   - `@Binding var selectedMethodID: PersistentIdentifier?`
   - `@Binding var selectedBeanID: PersistentIdentifier?`
   - `@Binding var startDate: Date?`
   - `@Binding var endDate: Date?`
   - `@Binding var minimumRating: Int`
   - `@Environment(\.dismiss) private var dismiss`

3. Add @Query properties to fetch available options:
   - `@Query(sort: \BrewMethod.name) private var methods: [BrewMethod]`
   - `@Query(filter: #Predicate<CoffeeBean> { !$0.isArchived }, sort: \CoffeeBean.createdAt, order: .reverse) private var beans: [CoffeeBean]`

4. Add a private `@State var dateFilterEnabled: Bool` computed from whether `startDate != nil` on appear. Initialize as `false` and use `.onAppear { dateFilterEnabled = startDate != nil }`.

5. Body: `NavigationStack` wrapping a `Form` with sections:

   **Section("Brew Method"):**
   - `Picker("Method", selection: $selectedMethodID)` with:
     - `Text("All Methods").tag(nil as PersistentIdentifier?)`
     - `ForEach(methods) { method in Text(method.name).tag(Optional(method.persistentModelID)) }`

   **Section("Coffee"):**
   - `Picker("Bean", selection: $selectedBeanID)` with:
     - `Text("All Coffees").tag(nil as PersistentIdentifier?)`
     - `ForEach(beans) { bean in Text(bean.displayName).tag(Optional(bean.persistentModelID)) }`

   **Section("Date Range"):**
   - `Toggle("Filter by date", isOn: $dateFilterEnabled)` with `.onChange(of: dateFilterEnabled)`: when toggled ON, set `startDate` to 30 days ago and `endDate` to now; when toggled OFF, set both to nil.
   - Conditionally (if `dateFilterEnabled`), show two `DatePicker` controls:
     - "From" bound to a non-optional binding: `Binding(get: { startDate ?? Date.distantPast }, set: { startDate = $0 })`, displayedComponents: `.date`
     - "To" bound similarly: `Binding(get: { endDate ?? Date() }, set: { endDate = $0 })`, displayedComponents: `.date`

   **Section("Minimum Rating"):**
   - `Picker("Rating", selection: $minimumRating)` with:
     - `Text("Any").tag(0)`
     - `ForEach(1...5, id: \.self) { r in Text("\(r)+ stars").tag(r) }`

   **Section (footer):**
   - `Button("Clear All Filters") { clearFilters() }` with `.foregroundStyle(AppColors.secondary)`.

6. Add `.navigationTitle("Filter Brews")` and `.navigationBarTitleDisplayMode(.inline)`.

7. Add toolbar with `ToolbarItem(placement: .topBarTrailing)` containing `Button("Done") { dismiss() }.foregroundStyle(AppColors.primary)`.

8. Implement `private func clearFilters()`:
   - Set `selectedMethodID = nil`, `selectedBeanID = nil`, `startDate = nil`, `endDate = nil`, `minimumRating = 0`, `dateFilterEnabled = false`.

**Design notes:**
- Use the app's monochrome design system -- no accent colors.
- All Pickers use default `.automatic` style (wheel on iOS, menu-style in Form).
- The sheet pattern follows AddBrewLogView (NavigationStack inside sheet).
  </action>
  <verify>
Build succeeds. BrewFilterSheet compiles with all @Binding parameters. Method and Bean pickers use PersistentIdentifier tags. Date range toggle correctly shows/hides DatePickers. Clear All resets all filter values.
  </verify>
  <done>
BrewFilterSheet presents a modal Form with method picker, bean picker, date range (toggle + two DatePickers), minimum rating picker, and a Clear All Filters button. All filter values are bound back to the parent view's state via @Binding.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Package.swift and verify end-to-end filtering</name>
  <files>
    Package.swift
  </files>
  <action>
1. Add the two new History view files to Package.swift sources array:
   - `"Views/History/BrewHistoryListContent.swift"`
   - `"Views/History/BrewFilterSheet.swift"`

2. Place them after the existing Brewing view entries for logical grouping.

3. Run `swift build` to verify the entire project compiles with the new files.

**Important:** The Package.swift is for CLI build verification only. Swift Charts (used in Plan 02) is a system framework that may not be available in SPM CLI builds. For THIS plan, no Charts import is needed -- all views use standard SwiftUI and SwiftData only.
  </action>
  <verify>
`swift build` succeeds from project root with 0 errors. All new files are included in the build. No warnings related to the new files.
  </verify>
  <done>
Package.swift includes both new History view files. CLI build passes, confirming all type references, imports, and @Query patterns compile correctly.
  </done>
</task>

</tasks>

<verification>
1. `swift build` passes with 0 errors
2. BrewLogListView has .searchable modifier and filter state
3. BrewHistoryListContent has #Predicate with scalar filters and in-memory relationship post-filter
4. BrewFilterSheet has method picker, bean picker, date range, rating filter, and Clear All
5. Filter icon in toolbar toggles between filled/unfilled based on hasActiveFilters
6. All filter bindings flow from parent through sheet and into child @Query reinitialization
</verification>

<success_criteria>
- Brew list displays chronologically (newest first) with search bar
- Typing in search bar filters brews by notes text in real-time
- Filter sheet allows selecting method, bean, date range, and minimum rating
- Multiple filter criteria can be combined simultaneously
- Filter icon shows filled state when any filter is active
- "Clear All Filters" resets all criteria and shows full brew list
- Empty state shown when no brews match current filters
- Existing swipe-to-delete and NavigationLink to detail view still work
</success_criteria>

<output>
After completion, create `.planning/phases/05-history-search/05-01-SUMMARY.md`
</output>
