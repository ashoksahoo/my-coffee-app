---
phase: 09-automated-qa-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CoffeeJournal/Utilities/AccessibilityIdentifiers.swift
  - CoffeeJournal/CoffeeJournalApp.swift
  - CoffeeJournalTests/Utilities/FreshnessCalculatorTests.swift
  - CoffeeJournalTests/Utilities/BagLabelParserTests.swift
  - CoffeeJournalTests/Utilities/BrewStepTemplatesTests.swift
  - CoffeeJournalTests/ViewModels/BrewLogViewModelTests.swift
  - CoffeeJournalTests/ViewModels/SetupWizardViewModelTests.swift
  - CoffeeJournalTests/ViewModels/TastingNoteViewModelTests.swift
  - CoffeeJournalTests/Helpers/TestHelpers.swift
autonomous: true

must_haves:
  truths:
    - "Pure business logic functions return correct results for boundary cases"
    - "ViewModel computed properties and state transitions behave correctly without SwiftData"
    - "Test target compiles and tests can be discovered by xcodebuild"
    - "UITESTING launch argument triggers in-memory ModelContainer"
  artifacts:
    - path: "CoffeeJournal/Utilities/AccessibilityIdentifiers.swift"
      provides: "Centralized accessibility identifier enum shared between app and test targets"
      contains: "enum AccessibilityID"
    - path: "CoffeeJournal/CoffeeJournalApp.swift"
      provides: "UITESTING launch argument support for in-memory storage"
      contains: "UITESTING"
    - path: "CoffeeJournalTests/Utilities/FreshnessCalculatorTests.swift"
      provides: "Unit tests for freshness calculation boundaries"
      contains: "@Suite"
    - path: "CoffeeJournalTests/Utilities/BagLabelParserTests.swift"
      provides: "Unit tests for bag label OCR parsing heuristics"
      contains: "@Suite"
    - path: "CoffeeJournalTests/Utilities/BrewStepTemplatesTests.swift"
      provides: "Unit tests for brew step template generation"
      contains: "@Suite"
    - path: "CoffeeJournalTests/ViewModels/BrewLogViewModelTests.swift"
      provides: "Unit tests for brew ratio, canSave, timer state machine"
      contains: "@Suite"
    - path: "CoffeeJournalTests/ViewModels/SetupWizardViewModelTests.swift"
      provides: "Unit tests for wizard step navigation and canProceed"
      contains: "@Suite"
    - path: "CoffeeJournalTests/ViewModels/TastingNoteViewModelTests.swift"
      provides: "Unit tests for flavor toggle, custom tags, hasChanges"
      contains: "@Suite"
  key_links:
    - from: "CoffeeJournalTests/**Tests.swift"
      to: "CoffeeJournal source files"
      via: "@testable import CoffeeJournal"
      pattern: "@testable import CoffeeJournal"
    - from: "CoffeeJournal/CoffeeJournalApp.swift"
      to: "CommandLine.arguments"
      via: "UITESTING argument check"
      pattern: "CommandLine.arguments.contains.*UITESTING"
---

<objective>
Create the test target infrastructure and comprehensive unit tests for all pure business logic.

Purpose: Establishes the testing foundation (CoffeeJournalTests target, AccessibilityIdentifiers, UITESTING in-memory support) and covers TEST-01 (utility unit tests) and TEST-02 (ViewModel unit tests). These tests validate the app's core logic without requiring SwiftData runtime.

Output: CoffeeJournalTests target with 6 test suites covering FreshnessCalculator, BagLabelParser, BrewStepTemplates, BrewLogViewModel, SetupWizardViewModel, and TastingNoteViewModel. AccessibilityIdentifiers.swift shared enum. App UITESTING in-memory ModelContainer support.
</objective>

<execution_context>
@/Users/ashok/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-automated-qa-suite/09-RESEARCH.md
@CoffeeJournal/Utilities/FreshnessCalculator.swift
@CoffeeJournal/Utilities/BagLabelParser.swift
@CoffeeJournal/Utilities/BrewStepTemplates.swift
@CoffeeJournal/ViewModels/BrewLogViewModel.swift
@CoffeeJournal/ViewModels/SetupWizardViewModel.swift
@CoffeeJournal/ViewModels/TastingNoteViewModel.swift
@CoffeeJournal/CoffeeJournalApp.swift
@CoffeeJournal/Models/MethodCategory.swift
@CoffeeJournal/Models/MethodTemplate.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test infrastructure and shared accessibility identifiers</name>
  <files>
    CoffeeJournal/Utilities/AccessibilityIdentifiers.swift
    CoffeeJournal/CoffeeJournalApp.swift
    CoffeeJournalTests/Helpers/TestHelpers.swift
  </files>
  <action>
    1. Create `CoffeeJournalTests/` directory structure:
       - CoffeeJournalTests/Utilities/
       - CoffeeJournalTests/ViewModels/
       - CoffeeJournalTests/Helpers/

    2. Create `CoffeeJournal/Utilities/AccessibilityIdentifiers.swift` with centralized `AccessibilityID` enum:
       - `AccessibilityID.Setup`: welcomeTitle, getStartedButton, methodSelectionTitle, continueButton, skipButton, completeTitle
       - `AccessibilityID.Tabs`: brews, beans, methods, grinders, settings
       - `AccessibilityID.Brews`: addButton, list, doseField, waterAmountField, saveButton, cancelButton, searchField
       - `AccessibilityID.Beans`: addButton, list, roasterField, nameField, originField, saveButton
       - `AccessibilityID.Equipment`: addMethodButton, addGrinderButton, grinderNameField, grinderSaveButton, methodList, grinderList
       - `AccessibilityID.Settings`: rerunWizardButton, syncSection
       - Use static let String properties with dot-path naming (e.g., "setup.welcome.title", "brews.add")
       - This file must be added to BOTH the main app target AND the CoffeeJournalTests AND CoffeeJournalUITests targets in the Xcode project.

    3. Modify `CoffeeJournal/CoffeeJournalApp.swift` to support UITESTING launch argument:
       - In the `init()` method, add a `#if DEBUG` block that checks `CommandLine.arguments.contains("UITESTING")`
       - When UITESTING is detected, create ModelConfiguration with `isStoredInMemoryOnly: true` and `cloudKitDatabase: .none`
       - Keep the existing non-test ModelConfiguration as the else branch
       - This enables UI tests to run with isolated in-memory data

    4. Create `CoffeeJournalTests/Helpers/TestHelpers.swift` with:
       - `import Testing` and `@testable import CoffeeJournal`
       - A helper function `makeDate(year:month:day:)` that creates a Date from components using Calendar.current (useful for freshness and date parsing tests)
       - A helper function `daysAgo(_ days: Int) -> Date` that returns a Date N days before now

    5. Add the CoffeeJournalTests target to the Xcode project (project.pbxproj):
       - Use `ruby` or direct pbxproj manipulation to add a unit test target named "CoffeeJournalTests"
       - The target should link to the CoffeeJournal app target as its host
       - Include all files under CoffeeJournalTests/ directory
       - Also include AccessibilityIdentifiers.swift in the test target's compile sources
       - If pbxproj manipulation is too complex, document the manual step and note that `xcodebuild test` with the existing scheme may auto-discover test targets

    IMPORTANT: The existing UI test file uses `app.launchArguments = ["UI_TESTING"]` (with underscore) but the research recommends `"UITESTING"` (no underscore). Use `"UITESTING"` consistently in the new code since we will rewrite the UI tests in Plan 02. Add support for BOTH in the app init to avoid breaking the existing skeleton tests during transition.
  </action>
  <verify>
    - `ls CoffeeJournalTests/Helpers/TestHelpers.swift` confirms file exists
    - `ls CoffeeJournal/Utilities/AccessibilityIdentifiers.swift` confirms file exists
    - `grep "UITESTING" CoffeeJournal/CoffeeJournalApp.swift` shows the launch argument check
    - `grep "isStoredInMemoryOnly: true" CoffeeJournal/CoffeeJournalApp.swift` shows in-memory config
  </verify>
  <done>
    AccessibilityIdentifiers.swift exists with all ID enums. CoffeeJournalApp.swift creates in-memory ModelContainer when UITESTING argument detected. CoffeeJournalTests directory structure created with TestHelpers.swift.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write pure business logic unit tests</name>
  <files>
    CoffeeJournalTests/Utilities/FreshnessCalculatorTests.swift
    CoffeeJournalTests/Utilities/BagLabelParserTests.swift
    CoffeeJournalTests/Utilities/BrewStepTemplatesTests.swift
    CoffeeJournalTests/ViewModels/BrewLogViewModelTests.swift
    CoffeeJournalTests/ViewModels/SetupWizardViewModelTests.swift
    CoffeeJournalTests/ViewModels/TastingNoteViewModelTests.swift
  </files>
  <action>
    Use Swift Testing framework (`import Testing`, `@Suite`, `@Test`, `#expect`) for ALL unit tests. These test pure logic with NO SwiftData dependency.

    1. **FreshnessCalculatorTests.swift** (`@Suite("FreshnessCalculator")`):
       - Test `freshnessLevel(daysSinceRoast:)` boundaries: day 0 = .peak, day 14 = .peak, day 15 = .acceptable, day 30 = .acceptable, day 31 = .stale
       - Test `daysSinceRoast(from:)` returns 0 for today, positive for past dates
       - Test FreshnessLevel computed properties: `.label`, `.opacity`, `.iconName` for each case
       - Test negative days clamped to 0 (future roast date)

    2. **BagLabelParserTests.swift** (`@Suite("BagLabelParser")`):
       - Test origin detection: ["Blue Bottle", "Ethiopia Yirgacheffe"] -> origin = "Ethiopia"
       - Test multi-word roast level priority: ["Medium Light Roast"] -> roastLevel = "medium_light" (not "medium")
       - Test variety detection: ["Gesha Lot 42"] -> variety = "Gesha"
       - Test processing method: ["Natural Process"] -> processingMethod = "natural"
       - Test roaster from first line: ["Counter Culture", "Ethiopia"] -> roaster = "Counter Culture"
       - Test ISO date parsing: ["Roasted 2026-01-15"] -> roastDate is not nil (use a recent date within 2-year window)
       - Test empty input: [] -> all fields nil
       - Test no match input: ["Some Random Text 12345"] -> origin nil, variety nil

    3. **BrewStepTemplatesTests.swift** (`@Suite("BrewStepTemplates")`):
       - Test `.pourOver` returns 4 steps: Bloom, First Pour, Second Pour, Drawdown
       - Test `.espresso` returns 2 steps: Pre-infusion, Extraction
       - Test `.immersion` returns 3 steps: Add Water, Steep, Plunge/Filter
       - Test `.other` returns 1 step: Brew
       - Test Bloom step has durationSeconds = 30 and waterPercentage ~0.13
       - Test Steep step has durationSeconds = 240

    4. **BrewLogViewModelTests.swift** (`@Suite("BrewLogViewModel")`):
       - Test `brewRatio` returns "--" when dose is 0
       - Test `brewRatio` returns "--" when waterAmount is 0 (non-espresso, selectedMethod is nil)
       - Test `brewRatio` calculates correctly: dose=15, waterAmount=250 -> "1:16.7"
       - Test `canSave` is false when no method selected (selectedMethod is nil) even if dose > 0
       - Test `canSave` is false when dose is 0 even if selectedMethod could be set
       - NOTE: Cannot test espresso-specific brewRatio or canSave with method because BrewMethod is @Model and may not instantiate without container. Skip espresso path tests here (covered in integration tests Plan 03).
       - Test `manualBrewTimeTotal`: brewTimeMinutes=3, brewTimeSeconds=30 -> 210.0
       - Test `hasUnsavedChanges` returns false for fresh VM, true after setting dose
       - Test timer state machine: idle -> startTimer -> running, running -> pauseTimer -> paused, paused -> resumeTimer -> running, running -> stopTimer -> stopped, stopped -> resetTimer -> idle
       - Test `resetTimer` clears elapsedSeconds, pausedElapsed, currentStepIndex, stepElapsedSeconds
       - Test `showsYield` is false when selectedMethod is nil (espresso path untestable without @Model)
       - Test `showsWaterAmount` is true when selectedMethod is nil

    5. **SetupWizardViewModelTests.swift** (`@Suite("SetupWizardViewModel")`):
       - Test initial state: currentStep = .welcome, selectedMethods is empty, grinderName is empty
       - Test `canProceed` at each step: welcome=true, methods with empty selection=false, methods with selection=true, grinder=true (optional), complete=true
       - Test `nextStep()` advances: welcome -> methods -> grinder -> complete
       - Test `nextStep()` at complete does not crash (stays at complete)
       - Test `previousStep()` goes back: complete -> grinder -> methods -> welcome
       - Test `previousStep()` at welcome does not crash (stays at welcome)
       - Test `stepTitle` for each step: "Welcome", "Your Brew Methods", "Your Grinder", "All Set!"
       - Test `stepNumber` returns 1-based: welcome=1, methods=2, grinder=3, complete=4
       - Test `totalSteps` returns 4
       - Test `reset()` returns to welcome with empty selections
       - Use MethodTemplate.curatedMethods for selection tests (MethodTemplate is a plain struct, no @Model)

    6. **TastingNoteViewModelTests.swift** (`@Suite("TastingNoteViewModel")`):
       - Test `toggleFlavor`: adding new ID inserts into selectedFlavorIds, toggling same ID removes it
       - Test `addCustomTag`: "vanilla" becomes "custom:vanilla" in customTags array, clears customTagInput
       - Test `addCustomTag` with empty/whitespace input does nothing
       - Test `addCustomTag` prevents duplicates
       - Test `removeCustomTag`: removes specific tag from customTags
       - Test `hasChanges`: false for fresh VM, true after setting acidity > 0, true after adding flavor, true after adding custom tag, true after setting freeformNotes
       - Test `allDisplayTags` returns sorted tags (test with custom tags only since FlavorWheel node lookup requires the static data which should work fine)
       - Test custom tag display name strips "custom:" prefix

    All tests use `#expect()` for assertions and `@Test("description")` for clear test naming.
  </action>
  <verify>
    - All 6 test files exist under CoffeeJournalTests/
    - Each file contains `import Testing` and `@testable import CoffeeJournal`
    - Each file has at least 5 test methods
    - `grep -r "@Test" CoffeeJournalTests/` shows test methods across all files
    - `grep -r "#expect" CoffeeJournalTests/` shows assertions in all test files
  </verify>
  <done>
    6 unit test suites exist covering FreshnessCalculator (boundary tests), BagLabelParser (origin/roast/date parsing), BrewStepTemplates (step counts and durations), BrewLogViewModel (ratio, validation, timer FSM), SetupWizardViewModel (navigation, canProceed), and TastingNoteViewModel (flavor toggle, custom tags, hasChanges). All use Swift Testing framework with descriptive @Test names and #expect assertions.
  </done>
</task>

</tasks>

<verification>
- CoffeeJournalTests/ directory contains 6 test files across Utilities/ and ViewModels/ subdirectories
- AccessibilityIdentifiers.swift exists with comprehensive ID coverage for all app screens
- CoffeeJournalApp.swift supports UITESTING in-memory ModelContainer
- All test files use Swift Testing framework (@Suite, @Test, #expect)
- No test file imports SwiftData or instantiates @Model classes directly
</verification>

<success_criteria>
- TEST-01 satisfied: Unit tests exist for FreshnessCalculator, BagLabelParser, BrewStepTemplates
- TEST-02 partially satisfied: Unit tests exist for BrewLogViewModel, SetupWizardViewModel, TastingNoteViewModel pure logic
- UITESTING infrastructure ready for Plan 02 UI tests and Plan 03 integration tests
- AccessibilityIdentifiers.swift ready for Plan 02 view wiring
</success_criteria>

<output>
After completion, create `.planning/phases/09-automated-qa-suite/09-01-SUMMARY.md`
</output>
